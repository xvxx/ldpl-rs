/*
 * BASICS
 */

// atoms
alpha = { ASCII_ALPHA | "_" }
digit = { ASCII_DIGIT }
WHITESPACE = _{ " " | "\t" | "\r" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// number: -3.14
sign = { "+" | "-" }
number = @{ sign? ~ digit+ ~ ("." ~ digit+)? }
number_list = @{ number ~ (" " ~ number)* }

// text: "Something something."
text = ${ "\"" ~ text_inner ~ "\"" }
text_inner = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t" | "e")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

// linefeed: lf, crlf
linefeed = { ^"LF" | ^"CRLF" }

// ident: name, something.with.dots, etc
ident = @{ alpha ~ (!banned ~ ANY)* }
banned = { ":" | "(" | ")" | "\"" | " " | "\t" | "\n" | "\r"} // https://docs.ldpl-lang.org/naming/

// lookup: person:"Name", list:5, etc
lookup = { ident ~ (":" ~ ( text | number | ident))+ }

// variable: name, something.with.dots, person:"Name", etc
var = { lookup | ident }

// expressions are either variables, text, or numbers.
expr = _{ var | number | text | linefeed }

// expr list: one two "three" 4 5 "six"
expr_list = @{ expr ~ (" " ~ expr)* }

// types TODO: x OF y..
basic_type = {
    ^"NUMBER LIST" |
    ^"NUMBER MAP" |
    ^"NUMBER" |
    ^"TEXT LIST" |
    ^"TEXT MAP" |
    ^"TEXT"
}
type_name = @{ basic_type }
type_def = { ident ~ ^"IS" ~ type_name }

// whole thing
program = _{
    SOI
    ~ "\n"*
    ~ (^"INCLUDE" ~ text ~ "\n"+)*
    ~ "\n"*
    ~ data_section?
    ~ "\n"*
    ~ (^"PROCEDURE:" ~ "\n"+)?
    ~ (proc_stmt ~ "\n"+)*
    ~ proc_stmt?
    ~ EOI
}

/*
 * DATA:
 */

data_section = _{
    ^"DATA:" ~ "\n"+
    ~ (type_def ~ "\n"+)*
}

/*
 * PROCEDURE:
 */

proc_stmt = {
    create_stmt_stmt |
    sub_def_stmt |
    subproc_stmt
}

subproc_stmt = {
    if_stmt
    | else_stmt
    | while_stmt
    | for_each_stmt
    | for_stmt
    | return_stmt
    | goto_stmt
    | label_stmt
    | store_stmt
    | exit_stmt
    | wait_stmt
    | call_stmt
    | solve_stmt
    | floor_stmt
    | ceil_stmt
    | mod_by_stmt
    | get_rand_stmt
    | raise_stmt
    | log_stmt
    | sin_stmt
    | cos_stmt
    | tan_stmt
    | join_stmt
    | replace_stmt
    | split_stmt
    | get_char_stmt
    | get_ascii_stmt
    | get_char_code_stmt
    | store_quote_stmt
    | get_index_stmt
    | count_stmt
    | substr_stmt
    | trim_stmt
    | get_length_stmt
    | push_stmt
    | delete_stmt
    | clear_stmt
    | copy_stmt
    | get_keys_count_stmt
    | get_keys_stmt
    | display_stmt
    | load_stmt
    | write_stmt
    | append_stmt
    | accept_stmt
    | execute_stmt
}


/*
 * SUB-PROCEDURES
 */

sub_def_stmt = {
    (^"SUB-PROCEDURE" | ^"SUB")
    ~ ident
    ~ "\n"+
    ~ (^"PARAMETERS:" ~ "\n"+ ~ (type_def ~ "\n"+)+)?
    ~ (^"LOCAL DATA:" ~ "\n"+ ~ (type_def ~ "\n"+)+)?
    ~ ^"PROCEDURE:"?
    ~ "\n"*
    ~ (subproc_stmt ~ "\n"+)*
    ~ "\n"*
    ~ (^"END SUB-PROCEDURE" | ^"END SUB")
}

/*
 * LDPL 4.4 PROCEDURE: STATEMENTS
 */

// FLOW

if_stmt = {
    ^"IF"
    ~ test_expr
    ~ ^"THEN"
    ~ "\n"+
    ~ (subproc_stmt ~ "\n"+ | else_stmt ~ "\n"+)*
    ~ "\n"*
    ~ ^"END IF"
}
else_stmt = {
    ^"ELSE" ~ ^"IF" ~ test_expr ~ ^"THEN" |
    ^"ELSE"
}

while_stmt = {
    ^"WHILE"
    ~ test_expr
    ~ ^"DO"
    ~ "\n"+
    ~ (subproc_stmt ~ "\n"+ | loop_kw_stmt ~ "\n"+)*
    ~ "\n"*
    ~ ^"REPEAT"
}

for_each_stmt = {
    ^"FOR EACH" ~ ident ~ ^"IN" ~ expr ~ ^"DO" ~ "\n"
    ~ (subproc_stmt ~ "\n"+ | loop_kw_stmt ~ "\n"+)*
    ~ "\n"*
    ~ ^"REPEAT"
}

for_stmt = {
    ^"FOR" ~ ident ~ ^"FROM" ~ expr ~ ^"TO" ~ expr ~ ^"STEP" ~ expr ~ ^"DO" ~ "\n"
    ~ (subproc_stmt ~ "\n"+ | loop_kw_stmt ~ "\n"+)*
    ~ "\n"*
    ~ ^"REPEAT"
}

test_expr = {
    expr ~ (
    ^"IS" ~ ^"EQUAL" ~ ^"TO" |
    ^"IS" ~ ^"NOT" ~ ^"EQUAL" ~ ^"TO" |
    ^"IS" ~ ^"GREATER" ~ ^"THAN" |
    ^"IS" ~ ^"LESS" ~ ^"THAN" |
    ^"IS" ~ ^"GREATER" ~ ^"THAN" ~ ^"OR" ~ ^"EQUAL" ~ ^"TO" |
    ^"IS" ~ ^"LESS" ~ ^"THAN" ~ ^"OR" ~ ^"EQUAL" ~ ^"TO"
    )
    ~ expr
}

loop_kw_stmt = { ^"BREAK" | ^"CONTINUE" }
return_stmt = { ^"RETURN" }
goto_stmt = { ^"GOTO" ~ ident }
label_stmt = { ^"LABEL" ~ ident }
store_stmt = { ^"STORE" ~ expr ~ ^"IN" ~ var }
exit_stmt = { ^"EXIT" }
wait_stmt = { ^"WAIT" ~ expr ~ ^"MILLISECONDS" }
create_stmt_stmt = { ^"CREATE" ~ ^"STATEMENT" ~ expr ~ ^"EXECUTING" ~ ident }

call_stmt = _{ call_external_stmt | call_verbose_stmt | call_sub_stmt }
call_external_stmt = { ^"CALL" ~ ^"EXTERNAL" ~ var ~ (^"WITH" ~ expr_list)? }
call_verbose_stmt = { ^"CALL" ~ ^"SUB-PROCEDURE" ~ var ~ (^"WITH" ~ expr_list)? }
call_sub_stmt = { ^"CALL" ~ var ~ (^"WITH" ~ expr_list)? }

// MATH

math_op = { "+" | "-" | "*" | "/" | "^" }
solve_expr = { ("(" | ")" | number | ident | math_op)+ }
solve_stmt = { ^"IN" ~ var ~ ^"SOLVE" ~ solve_expr }

floor_stmt = { floor_in_stmt | floor_expr_stmt }
floor_expr_stmt = { ^"FLOOR" ~ expr }
floor_in_stmt = { ^"FLOOR" ~ expr ~ ^"IN" ~ var }

ceil_stmt = { ceil_in_stmt | ceil_expr_stmt }
ceil_expr_stmt = { ^"CEIL" ~ expr }
ceil_in_stmt = { ^"CEIL" ~ expr ~ ^"IN" ~ var }

mod_by_stmt = { ^"MODULE" ~ expr ~ ^"BY" ~ expr ~ ^"IN" ~ var }
get_rand_stmt = { ^"GET" ~ ^"RANDOM" ~ ^"IN" ~ var }
raise_stmt = { ^"RAISE" ~ expr ~ ^"TO" ~ ^"THE" ~ expr ~ ^"IN" ~ var }
log_stmt = { ^"LOG" ~ expr ~ ^"IN" ~ var }
sin_stmt = { ^"SIN" ~ expr ~ ^"IN" ~ var }
cos_stmt = { ^"COS" ~ expr ~ ^"IN" ~ var }
tan_stmt = { ^"TAN" ~ expr ~ ^"IN" ~ var }

// TEXT

join_stmt = { ^"IN" ~ var ~ ^"JOIN" ~ expr_list }
replace_stmt = { ^"REPLACE" ~ expr ~ ^"FROM" ~ expr ~ ^"WITH" ~ expr ~ ^"IN" ~ var }
split_stmt = { ^"SPLIT" ~ expr ~ ^"BY" ~ expr ~ ^"IN" ~ var }
get_char_stmt = { ^"GET" ~ ^"CHARACTER" ~ ^"AT" ~ expr ~ ^"FROM" ~ expr ~ ^"IN" ~ var }
get_ascii_stmt = { ^"GET" ~ ^"ASCII" ~ ^"CHARACTER" ~ expr ~ ^"IN" ~ var }
get_char_code_stmt = { ^"GET" ~ ^"CHARACTER" ~ ^"CODE" ~ ^"OF" ~ expr ~ ^"IN" ~ var }
store_quote_stmt = { ^"STORE" ~ ^"QUOTE" ~ expr ~ ^"IN" ~ var }
get_index_stmt = { ^"GET" ~ ^"INDEX" ~ ^"OF" ~ expr ~ ^"FROM" ~ expr ~ ^"IN" ~ var }
count_stmt = { ^"COUNT" ~ expr ~ ^"FROM" ~ expr ~ ^"IN" ~ var }
substr_stmt = { ^"SUBSTRING" ~ expr ~ ^"FROM" ~ expr ~ ^"LENGTH" ~ expr ~ ^"IN" ~ var }
trim_stmt = { ^"TRIM" ~ expr ~ ^"IN" ~ var }

// TEXT & LIST

get_length_stmt = { ^"GET" ~ ^"LENGTH" ~ ^"OF" ~ expr ~ ^"IN" ~ var }

// LIST

push_stmt = { ^"PUSH" ~ expr ~ ^"TO" ~ expr }
delete_stmt = { ^"DELETE" ~ ^"LAST" ~ ^"ELEMENT" ~ ^"OF" ~ expr }

// LIST & MAP

clear_stmt = { ^"CLEAR" ~ expr }
copy_stmt = { ^"COPY" ~ expr ~ ^"TO" ~ var }

// MAP

get_keys_count_stmt = { ^"GET" ~ ^"KEY" ~ ^"COUNT" ~ ^"OF" ~ expr ~ ^"IN" ~ var }
get_keys_stmt = { ^"GET" ~ ^"KEYS" ~ ^"OF" ~ expr ~ ^"IN" ~ var }

// IO

display_stmt = { ^"DISPLAY" ~ expr_list }
load_stmt = { ^"LOAD" ~ ^"FILE" ~ expr ~ ^"IN" ~ var }
write_stmt = { ^"WRITE" ~ expr ~ ^"TO" ~ ^"FILE" ~ expr }
append_stmt = { ^"APPEND" ~ expr ~ ^"TO" ~ ^"FILE" ~ expr }

accept_stmt = _{ accept_eof_stmt | accept_var_stmt }
accept_var_stmt = { ^"ACCEPT" ~ var }
accept_eof_stmt = { ^"ACCEPT" ~ var ~ ^"UNTIL" ~ ^"EOF" }

execute_stmt = _{ execute_exit_code_stmt | execute_output_stmt | execute_expr_stmt }
execute_expr_stmt = { ^"EXECUTE" ~ expr }
execute_output_stmt = { ^"EXECUTE" ~ expr ~ ^"AND" ~ ^"STORE" ~ ^"OUTPUT" ~ ^"IN" ~ var }
execute_exit_code_stmt = { ^"EXECUTE" ~ expr ~ ^"AND" ~ ^"STORE" ~ ^"EXIT" ~ ^"CODE" ~ ^"IN" ~ var }
